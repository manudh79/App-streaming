<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Live Overlay ‚Äî Preview</title>
<style>
  :root{
    --accent:#e63946;
    --muted: rgba(0,0,0,0.45);
    --panel: rgba(0,0,0,0.55);
    --text:#fff;
    --ui-radius:12px;
  }
  html,body{height:100%;margin:0;background:#000;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  #app{height:100vh;display:flex;flex-direction:column;align-items:stretch;justify-content:flex-start;overflow:hidden;color:var(--text);} 
  /* top bar */
  .topbar{position:absolute;left:12px;top:12px;z-index:40;display:flex;align-items:center;gap:10px;}
  .badge{background:var(--panel);padding:8px 12px;border-radius:999px;font-weight:600;box-shadow:0 4px 12px rgba(0,0,0,0.45);} 
  /* right small end button */
  .endBtn{position:absolute;right:12px;top:12px;z-index:40;background:var(--panel);border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer}
  .endBtn:hover{transform:scale(1.03)}
  /* video area */
  #preview{flex:1;position:relative;background:#000;display:flex;align-items:center;justify-content:center;overflow:hidden;}
  video{display:block;min-width:100%;min-height:100%;object-fit:cover;transform:scaleX(-1);} /* mirror so it feels natural when front; we'll flip if rear */
  canvas{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:20}
  /* comments container on the right (overlay) */
  .commentsBox{position:absolute;right:12px;top:70px;z-index:30;display:flex;flex-direction:column;gap:8px;max-width:36%;min-width:180px;pointer-events:none;}
  .comment{
    background: linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.32));
    padding:8px 12px;border-radius:10px;color:var(--text);font-size:16px;line-height:1.1;direction:rtl;
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
    opacity:0; transform: translateY(8px) scale(0.99); transition: transform 300ms ease, opacity 400ms ease;
    pointer-events:none;
  }
  .comment.show{opacity:1; transform: translateY(0) scale(1);} 
  .comment .meta{font-size:12px;opacity:0.85;margin-bottom:4px;text-align:left}
  /* reaction floating */
  .reaction{position:absolute;z-index:35;font-size:26px;pointer-events:none;will-change:transform,opacity;}
  /* hidden controls panel (appears after long press) */
  .controlsPanel{
    position: absolute; left:50%; bottom:22px; transform:translateX(-50%); z-index:50;
    background:rgba(0,0,0,0.6); padding:10px 12px; border-radius:999px; display:flex; gap:10px; align-items:center;
    box-shadow:0 10px 30px rgba(0,0,0,0.6); opacity:0; pointer-events:none; transition:opacity 220ms ease;
  }
  .controlsPanel.visible{opacity:1; pointer-events:auto;}
  .iconBtn{width:56px;height:56px;border-radius:999px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-size:20px;cursor:pointer;border:0;color:var(--text);font-weight:700}
  .iconBtn.record{background:linear-gradient(90deg,var(--accent), #ff7b7b);box-shadow:0 8px 30px rgba(230,57,70,0.18)}
  /* small footer prompt for first time */
  .hint{position:absolute;left:12px;bottom:16px;z-index:40;background:var(--panel);padding:8px 12px;border-radius:10px;font-size:13px;opacity:0.9}
  /* styles to make it feel native */
  @media (max-width:720px){
    .commentsBox{max-width:58%;right:10px;top:86px}
    .iconBtn{width:52px;height:52px}
  }
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="badge" id="viewers">üëÅÔ∏è 1.2k</div>
  </div>
  <div class="endBtn" id="endBtn" title="End">‚úñ</div>

  <div id="preview">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <!-- comments DOM (for better layout control) -->
    <div class="commentsBox" id="commentsBox" aria-hidden="true"></div>

    <!-- reactions are created dynamically -->
    <div class="controlsPanel" id="controlsPanel" aria-hidden="true">
      <button class="iconBtn" id="switchCam" title="Switch camera">üîÑ</button>
      <button class="iconBtn record" id="recordBtn" title="Record">‚è∫</button>
      <button class="iconBtn" id="stopBtn" title="Stop" disabled>‚èπ</button>
      <button class="iconBtn" id="downloadBtn" title="Download" disabled>‚¨áÔ∏è</button>
    </div>

    <div class="hint" id="hint">Long press center to open controls</div>
  </div>
</div>

<script>
/* ---------- Config ---------- */
const MAX_VISIBLE = 6;
const COMMENT_DURATION = 7000; // ms
const COMMENT_FADE = 600; // fadeout duration
const REACTION_EMOJIS = ['‚ù§Ô∏è','üî•','üòÇ','üëè','üëç'];
let usingRear = true;

/* ---------- Elements ---------- */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const commentsBox = document.getElementById('commentsBox');
const viewersBadge = document.getElementById('viewers');
const controlsPanel = document.getElementById('controlsPanel');
const recordBtn = document.getElementById('recordBtn');
const stopBtn = document.getElementById('stopBtn');
const downloadBtn = document.getElementById('downloadBtn');
const switchCam = document.getElementById('switchCam');
const endBtn = document.getElementById('endBtn');
const hint = document.getElementById('hint');

let mediaStream = null;
let mediaRecorder = null;
let recordedBlobs = [];
let recording = false;

/* ---------- Arabic sample comments (RTL) ---------- */
const sampleComments = [
  'ŸÖÿß Ÿáÿ∞ÿß ÿßŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ÿßŸÑÿ±ÿßÿ¶ÿπ!',
  'ÿ£ŸäŸÜ ÿ£ŸÜÿ™ŸÖ ÿßŸÑÿ¢ŸÜÿü',
  'ŸÖŸàÿ≥ŸäŸÇŸâ ÿßŸÑÿÆŸÑŸÅŸäÿ© ÿ¨ŸÖŸäŸÑÿ© üéµ',
  'ÿ™ÿ≠Ÿäÿßÿ™ŸÜÿß ŸÖŸÜ ÿ¨ÿ≤ÿ± ÿßŸÑŸÉŸÜÿßÿ±Ÿä üå¥',
  'ŸáŸÑ ŸäŸÖŸÉŸÜ ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ•ÿπÿßÿØÿ©ÿü',
  'ÿ≠ÿ∏ÿßŸã ŸÖŸàŸÅŸÇÿßŸã! ‚ù§Ô∏è',
  'ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿ¥ÿßÿ¥ÿ© ŸÖŸÖÿ™ÿßÿ≤ÿ©!',
  'ŸÉŸÖ ÿπŸÖÿ± Ÿáÿ∞ÿß ÿßŸÑŸÖŸÉÿßŸÜÿü',
  'ŸÖÿ≠ÿ™ŸàŸâ ŸÖŸÅŸäÿØ ÿ¨ÿØÿßŸãÿå ÿ¥ŸÉÿ±ÿßŸã!',
  'ÿ£ÿ≠ÿ® ÿßŸÑÿ¨ŸÖŸáŸàÿ± ŸáŸÜÿß üî•'
];

/* ---------- Helpers ---------- */
function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

function createCommentNode(text){
  const el = document.createElement('div');
  el.className = 'comment';
  // optional meta line (time or username) ‚Äî keep minimal to avoid likeness
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = 'Viewer';
  meta.style.textAlign = 'left';
  el.appendChild(meta);
  const txt = document.createElement('div');
  txt.style.direction = 'rtl';
  txt.textContent = text;
  el.appendChild(txt);
  return el;
}

/* add comment to DOM stack (one below another) */
function pushComment(text){
  // limit number of child nodes
  while(commentsBox.children.length >= MAX_VISIBLE){
    const first = commentsBox.children[0];
    fadeOutAndRemove(first);
  }
  const node = createCommentNode(text);
  commentsBox.appendChild(node);
  // trigger show animation
  requestAnimationFrame(()=> node.classList.add('show'));
  // spawn reaction sometimes
  if(Math.random() < 0.5) spawnReaction();
  // schedule removal
  setTimeout(()=> fadeOutAndRemove(node), COMMENT_DURATION);
}

function fadeOutAndRemove(node){
  node.style.transition = `opacity ${COMMENT_FADE}ms ease, transform ${COMMENT_FADE}ms ease`;
  node.style.opacity = '0';
  node.style.transform = 'translateY(-10px) scale(0.98)';
  setTimeout(()=>{ if(node && node.remove) node.remove(); }, COMMENT_FADE + 50);
}

/* reactions: floating emoji from bottom-right area */
function spawnReaction(){
  const emoji = REACTION_EMOJIS[Math.floor(Math.random()*REACTION_EMOJIS.length)];
  const el = document.createElement('div');
  el.className = 'reaction';
  el.textContent = emoji;
  // start position
  const startX = window.innerWidth * 0.75 + (Math.random()*40 - 20);
  const startY = window.innerHeight - 160 + (Math.random()*30 - 10);
  el.style.left = startX + 'px';
  el.style.top = startY + 'px';
  el.style.opacity = '1';
  el.style.transform = 'translateY(0)';
  document.body.appendChild(el);

  // animate up + fade
  const duration = 2200 + Math.random()*1000;
  const dx = (Math.random()*-40) + (Math.random()*40);
  const dy = - (120 + Math.random()*70);
  const start = performance.now();
  function step(now){
    const t = Math.min(1, (now - start) / duration);
    const ease = 1 - Math.pow(1 - t, 3);
    el.style.transform = `translate(${dx * ease}px, ${dy * ease}px)`;
    el.style.opacity = String(1 - ease);
    if(t < 1) requestAnimationFrame(step);
    else { el.remove(); }
  }
  requestAnimationFrame(step);
}

/* ---------- Camera & Canvas drawing ---------- */
async function startCamera(){
  stopCamera();
  const constraints = {
    audio: true,
    video: {
      facingMode: usingRear ? { exact: "environment" } : "user",
      width: { ideal: 1280 },
      height: { ideal: 720 }
    }
  };
  try{
    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
  }catch(e){
    // try without exact environment if not supported
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true });
    }catch(err){
      alert('Camera access is required. Please allow camera/mic permissions.');
      console.error(err);
      return;
    }
  }

  // attach to video
  video.srcObject = mediaStream;

  // if using rear, do not mirror
  video.style.transform = usingRear ? 'scaleX(1)' : 'scaleX(-1)';

  await video.play();
  resizeCanvas();
  startDrawLoop();
}

/* stop camera */
function stopCamera(){
  if(mediaStream){
    mediaStream.getTracks().forEach(t=>t.stop());
    mediaStream = null;
  }
}

/* canvas drawing loop: draw video to canvas so we can record overlay */
let drawId = null;
function resizeCanvas(){
  const rect = video.getBoundingClientRect();
  const ratio = window.devicePixelRatio || 1;
  canvas.width = Math.max(320, Math.floor(rect.width * ratio));
  canvas.height = Math.max(240, Math.floor(rect.height * ratio));
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
}

/* draw video frame + optional decorations to canvas (we keep DOM comments separate for crisp text) */
function drawFrame(){
  if(!video || video.readyState < 2) return;
  const cw = canvas.width;
  const ch = canvas.height;
  // draw video (cover)
  ctx.clearRect(0,0,cw,ch);
  try{
    ctx.drawImage(video, 0, 0, cw, ch);
  }catch(e){ /* sometimes video not ready */ }

  // overlays drawn on canvas: small viewers badge top-left and brand placeholder top-center
  // viewers badge
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  const pad = 14;
  ctx.font = `${16 * (canvas.width/800)}px sans-serif`;
  const text = viewersBadge.textContent;
  const m = ctx.measureText(text);
  const bw = Math.round(m.width + pad);
  const bh = 36 * (canvas.width/800);
  ctx.fillRect(12* (canvas.width/800), 12* (canvas.width/800), bw, bh);
  ctx.fillStyle = '#fff';
  ctx.fillText(text, 20* (canvas.width/800), 12*(canvas.width/800) + (bh - 10) );
  ctx.restore();
}

/* loop */
function startDrawLoop(){
  if(drawId) cancelAnimationFrame(drawId);
  function loop(){ drawFrame(); drawId = requestAnimationFrame(loop); }
  drawId = requestAnimationFrame(loop);
}

/* ---------- Recording ---------- */
function startRecording(){
  if(recording) return;
  // capture stream from canvas so that overlay + video are recorded (DOM comments will not be captured automatically,
  // so we also paint a simplified comments snapshot onto canvas periodically to include them in recording)
  const stream = canvas.captureStream(30);
  // also merge audio tracks (if any) from mediaStream
  if(mediaStream){
    const audioTracks = mediaStream.getAudioTracks();
    if(audioTracks && audioTracks.length){
      const audioCtx = new MediaStream();
      audioTracks.forEach(t => stream.addTrack(t));
    }
  }
  recordedBlobs = [];
  try{
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  }catch(e){
    try{ mediaRecorder = new MediaRecorder(stream); }catch(err){ alert('Recording not supported in this browser.'); console.error(err); return; }
  }
  mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordedBlobs.push(e.data); };
  mediaRecorder.onstop = onRecordingStop;
  mediaRecorder.start();
  recording = true;
  recordBtn.setAttribute('disabled','true');
  stopBtn.removeAttribute('disabled');
  downloadBtn.setAttribute('disabled','true');
  // small visual pulse
  recordBtn.classList.add('recording');
}

function stopRecording(){
  if(!recording || !mediaRecorder) return;
  mediaRecorder.stop();
  recording = false;
  recordBtn.removeAttribute('disabled');
  stopBtn.setAttribute('disabled','true');
  downloadBtn.removeAttribute('disabled');
  recordBtn.classList.remove('recording');
}

function onRecordingStop(){
  const blob = new Blob(recordedBlobs, { type: 'video/webm' });
  const url = URL.createObjectURL(blob);
  // enable download with blob url
  downloadBtn.dataset.url = url;
  downloadBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url;
    a.download = 'live_overlay.webm';
    document.body.appendChild(a);
    a.click();
    a.remove();
    // revoke after a short while
    setTimeout(()=> URL.revokeObjectURL(url), 2000);
  };
}

/* ---------- Long press to show controls ---------- */
let pressTimer = null;
let pressPos = null;
const pressDuration = 2000;
const previewArea = document.getElementById('preview');
previewArea.addEventListener('pointerdown',(e)=>{
  pressPos = {x:e.clientX,y:e.clientY};
  pressTimer = setTimeout(()=>{ controlsPanel.classList.add('visible'); }, pressDuration);
});
window.addEventListener('pointerup',()=>{
  if(pressTimer){ clearTimeout(pressTimer); pressTimer = null; }
});
/* hide panel if user taps outside */
document.addEventListener('click',(e)=>{
  if(!controlsPanel.contains(e.target) && !previewArea.contains(e.target)) return;
  // if click inside preview but not long press, do nothing
});
/* also hide on end button */
endBtn.addEventListener('click', ()=> { if(confirm('End stream preview?')) { window.location.reload(); } });

/* ---------- UI hooks ---------- */
recordBtn.addEventListener('click', ()=>{ startRecording(); });
stopBtn.addEventListener('click', ()=>{ stopRecording(); });
switchCam.addEventListener('click', async ()=>{ usingRear = !usingRear; await startCamera(); });

/* ---------- Comments generator (simulate) ---------- */
let commentInterval = null;
function startComments(){
  if(commentInterval) clearInterval(commentInterval);
  commentInterval = setInterval(()=>{
    const txt = sampleComments[Math.floor(Math.random()*sampleComments.length)];
    pushComment(txt);
  }, 1800 + Math.random()*1600);
}

/* ---------- Start everything ---------- */
async function init(){
  await startCamera();
  // ensure layout sizes
  await wait(250);
  resizeCanvas();
  startComments();
  // hide hint after some seconds
  setTimeout(()=>{ if(hint) hint.style.display = 'none'; }, 4500);
}
init();

/* ---------- resize handling ---------- */
window.addEventListener('resize', ()=>{ resizeCanvas(); });

/* ---------- make sure comments are included in recording:
   we periodically paint a snapshot of visible comments onto the canvas so they appear in the recorded video. */
setInterval(()=> {
  // draw a minimal comments snapshot in the same style as DOM on canvas (top-right)
  if(!ctx) return;
  ctx.save();
  const cw = canvas.width, ch = canvas.height;
  // draw semi-transparent box
  const boxW = Math.min(cw * 0.36, 600);
  const boxX = cw - boxW - 20;
  const boxY = 70 * (cw/800);
  ctx.fillStyle = 'rgba(0,0,0,0.0)'; // keep mostly transparent, comments text will be drawn
  // draw each comment text
  const nodes = Array.from(commentsBox.children);
  ctx.textAlign = 'right';
  ctx.direction = 'rtl';
  ctx.fillStyle = '#fff';
  const fontSize = Math.max(14, Math.round(18 * (cw/800)));
  ctx.font = `${fontSize}px sans-serif`;
  let y = boxY + fontSize;
  for(let i = nodes.length - 1; i >= 0; i--){
    const txt = nodes[i].innerText || nodes[i].textContent || '';
    const lines = wrapTextCanvas(ctx, txt, boxW - 28);
    for(let li = 0; li < lines.length; li++){
      ctx.fillText(lines[li], cw - 28, y);
      y += fontSize + 6;
    }
    y += 6;
  }
  ctx.restore();
}, 300);

/* helper to wrap text on canvas */
function wrapTextCanvas(context, text, maxWidth){
  const words = text.split(' ');
  let lines = [], cur = '';
  for(let w of words){
    const test = cur? (w + ' ' + cur) : w;
    const width = context.measureText(test).width;
    if(width > maxWidth){
      if(cur) lines.push(cur);
      cur = w;
    }else cur = test;
  }
  if(cur) lines.push(cur);
  return lines.slice(0,4);
}

/* allow user to tap centre to send a custom comment (for testing) */
previewArea.addEventListener('dblclick', ()=>{ pushComment('Ÿáÿ∞ÿß ÿ™ÿπŸÑŸäŸÇ ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ'); });

/* Accessibility: keyboard shortcuts (desktop testing) */
window.addEventListener('keydown',(e)=>{
  if(e.key === 'r') startRecording();
  if(e.key === 's') stopRecording();
  if(e.key === 'c') switchCam.click();
});

</script>
</body>
</html>
